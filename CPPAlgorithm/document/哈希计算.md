本程序的哈希算法主要用于 glTF 网格（Mesh）、图元（Primitive）、属性（Attribute）等结构的唯一性判定和分组。其核心思想是：将结构体的各个关键字段（如材质、模式、属性数据等）分别哈希后，递归合并成一个总的哈希值。下面详细说明实现方式：

---

## 1. 哈希合并（hash_combine）

在 `instancing_detector.h` 中定义了如下模板函数：

```cpp
template class T
inline void hash_combine(stdsize_t& seed, const T& v) {
    stdhashT hasher;
    seed ^= hasher(v) + 0x9e3779b9 + (seed  6) + (seed  2);
}
```
- 这是业界常用的哈希合并公式，能有效减少哈希碰撞。
- 其本质是将新字段的哈希值扰动后与已有哈希值合并。

---

## 2. MeshPrimitiveAttribute 的哈希流程

### Mesh 哈希
- 遍历 mesh 下的每个 primitive，分别计算其哈希值，再用 `hash_combine` 合并到 mesh 的总哈希值。

### Primitive 哈希
- 对 material、mode、attribute、morph target 等字段分别哈希并合并。
- 对 attribute，先哈希属性名，再对属性数据调用 `hashAccessorData`。

### Attribute 数据哈希（hashAccessorData）
- 对于法线（NORMAL）等支持容差的属性，先将每个分量按容差量化（如 `glmround(v  tolerance)`），再分别哈希每个分量。
- 对于一般属性，直接用 `stdhashstdstring_view` 对原始二进制数据做哈希。
- 如果数据不可用，则对 accessor 的属性（如 type、componentType、count、minmax）做哈希合并。

### 伪代码示例
```cpp
size_t mesh_hash = 0;
for (primitive in mesh.primitives) {
    size_t primitive_hash = 0;
    hash_combine(primitive_hash, primitive.material);
    hash_combine(primitive_hash, primitive.mode);
     ...对 attributes、indices、morph targets 递归调用 hash_combine ...
    hash_combine(mesh_hash, primitive_hash);
}
```

---

## 3. CesiumUtilityHashcombine（外部库）

部分地方还用到了 Cesium 的高级哈希混合函数，其本质是多轮移位、乘法和异或，进一步增强分布性：

```cpp
inline stdsize_t mix(stdsize_t x) {
  stdsize_t const m = 0xe9846af9b1a615d;
  x ^= x  32;
  x = m;
  x ^= x  32;
  x = m;
  x ^= x  28;
  return x;
}
stdsize_t Hashcombine(stdsize_t first, stdsize_t second) {
  return mix(first + 0x9e3779b9 + second);
}
```

---

## 4. 文件哈希（SHA256）

在 `utilities.cpp` 里有文件哈希的占位实现，实际应用建议用 OpenSSLCrypto++ 等库的 SHA256。

---

## 总结

本程序的哈希算法流程：
1. 对每个结构体的关键字段分别用 `stdhash` 计算哈希值。
2. 用 `hash_combine` 公式递归合并所有字段的哈希值，得到整体结构的唯一哈希。
3. 对于二进制数据（如顶点属性），直接用 `stdhashstdstring_view`。
4. 对于支持容差的属性（如法线），先量化再哈希。

公式核心：
[
text{seed} = text{seed} oplus (text{hasher}(v) + 0x9e3779b9 + (text{seed} ll 6) + (text{seed} gg 2))
]
本程序的哈希算法主要用于 glTF 网格（Mesh）、图元（Primitive）、属性（Attribute）等结构的唯一性判定和分组。其核心思想是：**将结构体的各个关键字段（如材质、模式、属性数据等）分别哈希后，递归合并成一个总的哈希值**。下面详细说明实现方式：

---

## 1. 哈希合并（hash_combine）

在 `instancing_detector.h` 中定义了如下模板函数：

```cpp
template <class T>
inline void hash_combine(std::size_t& seed, const T& v) {
    std::hash<T> hasher;
    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}
```
- 这是业界常用的哈希合并公式，能有效减少哈希碰撞。
- 其本质是将新字段的哈希值扰动后与已有哈希值合并。

---

## 2. Mesh/Primitive/Attribute 的哈希流程

### Mesh 哈希
- 遍历 mesh 下的每个 primitive，分别计算其哈希值，再用 `hash_combine` 合并到 mesh 的总哈希值。

### Primitive 哈希
- 对 material、mode、attribute、morph target 等字段分别哈希并合并。
- 对 attribute，先哈希属性名，再对属性数据调用 `hashAccessorData`。

### Attribute 数据哈希（hashAccessorData）
- 对于法线（NORMAL）等支持容差的属性，先将每个分量按容差量化（如 `glm::round(v / tolerance)`），再分别哈希每个分量。
- 对于一般属性，直接用 `std::hash<std::string_view>` 对原始二进制数据做哈希。
- 如果数据不可用，则对 accessor 的属性（如 type、componentType、count、min/max）做哈希合并。

### 伪代码示例
```cpp
size_t mesh_hash = 0;
for (primitive in mesh.primitives) {
    size_t primitive_hash = 0;
    hash_combine(primitive_hash, primitive.material);
    hash_combine(primitive_hash, primitive.mode);
    // ...对 attributes、indices、morph targets 递归调用 hash_combine ...
    hash_combine(mesh_hash, primitive_hash);
}
```

---

## 3. CesiumUtility::Hash::combine（外部库）

部分地方还用到了 Cesium 的高级哈希混合函数，其本质是多轮移位、乘法和异或，进一步增强分布性：

```cpp
inline std::size_t mix(std::size_t x) {
  std::size_t const m = 0xe9846af9b1a615d;
  x ^= x >> 32;
  x *= m;
  x ^= x >> 32;
  x *= m;
  x ^= x >> 28;
  return x;
}
std::size_t Hash::combine(std::size_t first, std::size_t second) {
  return mix(first + 0x9e3779b9 + second);
}
```

---

## 4. 文件哈希（SHA256）

在 `utilities.cpp` 里有文件哈希的占位实现，实际应用建议用 OpenSSL/Crypto++ 等库的 SHA256。

---

## 总结

**本程序的哈希算法流程：**
1. 对每个结构体的关键字段分别用 `std::hash` 计算哈希值。
2. 用 `hash_combine` 公式递归合并所有字段的哈希值，得到整体结构的唯一哈希。
3. 对于二进制数据（如顶点属性），直接用 `std::hash<std::string_view>`。
4. 对于支持容差的属性（如法线），先量化再哈希。

**公式核心：**
\[
\text{seed} = \text{seed} \oplus (\text{hasher}(v) + 0x9e3779b9 + (\text{seed} \ll 6) + (\text{seed} \gg 2))
\]


在本程序（以及大多数 C++ 工程）中，哈希计算的底层公式主要有两类：

---

## 1. 单个字段的哈希（std::hash）

对于基本类型（如 `int`、`double`、`std::string` 等），C++ 标准库提供了 `std::hash<T>`，其底层实现因类型和编译器不同而异，但本质都是将输入数据通过一系列位运算、乘法、加法等扰动，生成一个 `std::size_t` 类型的哈希值。

**例子：**
```cpp
std::hash<int> int_hasher;
size_t hash_value = int_hasher(42); // 对整数42进行哈希
```

---

## 2. 多字段哈希合并（hash_combine）

当需要对结构体或多个字段合成一个哈希值时，常用如下底层公式（本项目和 Boost、Qt 等一致）：

\[
\text{seed} = \text{seed} \oplus \left( \text{hasher}(v) + 0x9e3779b9 + (\text{seed} \ll 6) + (\text{seed} \gg 2) \right)
\]

**各部分含义：**
- \(\text{seed}\)：累计哈希值（初始为0或其它种子）
- \(\text{hasher}(v)\)：新字段的哈希值
- \(0x9e3779b9\)：黄金分割常数，扰动用
- \((\text{seed} \ll 6)\)：seed左移6位，增加变化
- \((\text{seed} \gg 2)\)：seed右移2位，增加变化
- \(\oplus\)：异或操作，混合新旧哈希

**C++实现：**
```cpp
template <class T>
inline void hash_combine(std::size_t& seed, const T& v) {
    std::hash<T> hasher;
    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}
```

---

## 3. 进阶哈希混合（如 splitmix64/murmur）

在 CesiumUtility::Hash::combine 里，还用到了更复杂的扰动公式（见 `extern/cesium-native/CesiumUtility/src/Hash.cpp`）：

\[
\begin{align*}
x &\mathrel{\oplus}= x \gg 32 \\
x &*= 0xe9846af9b1a615d \\
x &\mathrel{\oplus}= x \gg 32 \\
x &*= 0xe9846af9b1a615d \\
x &\mathrel{\oplus}= x \gg 28 \\
\end{align*}
\]

这种公式来源于 splitmix64、MurmurHash 等现代哈希算法，能进一步增强分布性和抗碰撞能力。

---

## 4. 二进制数据哈希

对于二进制数据（如顶点属性），常用如下底层公式：

\[
\text{hash\_value} = \text{std::hash<std::string\_view>}(二进制数据)
\]

---

## 总结

**本程序哈希计算的底层公式核心为：**

- **单字段**：`std::hash<T>(v)`
- **多字段合并**：
  \[
  \text{seed} = \text{seed} \oplus (\text{hasher}(v) + 0x9e3779b9 + (\text{seed} \ll 6) + (\text{seed} \gg 2))
  \]
- **进阶扰动**（如 splitmix64）：
  \[
  x \mathrel{\oplus}= x \gg 32; \quad x *= m; \quad x \mathrel{\oplus}= x \gg 32; \quad x *= m; \quad x \mathrel{\oplus}= x \gg 28;
  \]

这些公式保证了哈希值的分布均匀、碰撞概率低，适合结构体、复合数据的哈希判等和分组。